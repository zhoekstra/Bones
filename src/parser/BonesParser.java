package parser; 
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
@SuppressWarnings("unchecked")
public class BonesParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short MINUS = 1;
		static public final short LPAR = 2;
		static public final short ID = 3;
		static public final short F_GT = 4;
		static public final short F_GE = 5;
		static public final short F_LT = 6;
		static public final short F_LE = 7;
		static public final short F_EQ = 8;
		static public final short F_NEQ = 9;
		static public final short F_HIGHEST = 10;
		static public final short F_LOWEST = 11;
		static public final short F_PICK = 12;
		static public final short LBRA = 13;
		static public final short F_INPUT = 14;
		static public final short F_SIZEOF = 15;
		static public final short D4 = 16;
		static public final short D6 = 17;
		static public final short D8 = 18;
		static public final short D10 = 19;
		static public final short D12 = 20;
		static public final short D20 = 21;
		static public final short INTLIT = 22;
		static public final short BANG = 23;
		static public final short UNION = 24;
		static public final short COMPLEMENT = 25;
		static public final short INTERSECT = 26;
		static public final short NEQ = 27;
		static public final short EQ = 28;
		static public final short GT = 29;
		static public final short EQGT = 30;
		static public final short LT = 31;
		static public final short EQLT = 32;
		static public final short PLUS = 33;
		static public final short MULT = 34;
		static public final short DIV = 35;
		static public final short MOD = 36;
		static public final short RPAR = 37;
		static public final short COMMA = 38;
		static public final short LCUR = 39;
		static public final short FOR = 40;
		static public final short VAR = 41;
		static public final short CONSTVAR = 42;
		static public final short IF = 43;
		static public final short WHILE = 44;
		static public final short PRINT = 45;
		static public final short SEMI = 46;
		static public final short RBRA = 47;
		static public final short RCUR = 48;
		static public final short ASN = 49;
		static public final short STRING = 50;
		static public final short FUNC = 51;
		static public final short RETURN = 52;
		static public final short COLO = 53;
		static public final short ELSEIF = 54;
		static public final short EXPLODE = 55;
		static public final short DESPLODE = 56;
		static public final short ROLLAGAIN = 57;
		static public final short IN = 58;
		static public final short TO = 59;
		static public final short ELSE = 60;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjM7Ty54KK$gul0j9450jDcYWHY9H480e40Wc4eg1Y0SK6Y0rxeoXsG6meHQNtBXP4EWf" +
		"4UczYxmgANSVlPbykUtkNtGiO$xhBxyqtyzutxqtRAG6CdUY27BJ2LUY3lhWLT#413C4J68" +
		"bkU0bZSIakm#NeYIjm9TeZjuZiqkY0R2n4RTH5FLo8bcY2PkfljHlji2nQYtGqL$km6pMB6" +
		"2E8YdW3xw0aJaSrYyyyjQTO#pQtMBqdsKbsafra9zb9TfATP1S$EoNsFePJzVqjdYLMSouQ" +
		"e17ETx0yYc7qzPg5SOcDdG839rXkXeNxUXhFE5YVm$Fq5Nqpl5ZtfGpyo8CF6n32F9H006T" +
		"gVU6#KbYZ5FPXaUQjOOroc82pC0TUsifZ8jix2JNK15H71GS$9phOAjFJIRRshiSczIjEHb" +
		"dQAc4Newn2BTs6KnmyLN6mTQAdPROeTRJ7iyCfe#MF$3ckOnBjvJISWHwehsjLZR4w#UdjO" +
		"BsMzlEqpuQkxRc1riBjDv6HgdsqHgQZdvjnDQvpODn2JcFjgP#ZdplGrANDTvALvjglUt61" +
		"vjpcmBgVl9TnjwEVXz52#taGGnruWybynS7#EEqPsiz5BYqVWHIrpi7#ebwBflr9FEl0V1M" +
		"ZCQu8Qt4AtgRdBDs#ZZhjhDEkhcEz3DqrfvTE5#Czc#ThjFxw8duRRs8bRjHr9kiO$NL#W4" +
		"vdE$Zve0Wnbc07RfUzUg36UtHwdqjRdI8iq7KVqkaWdRRbgtqDBO$eqcCwdOysM7sC4PxI7" +
		"eRhT9HENv0#ZDVukawdOZfc7cC4i#uqxMU6JcT9XBSqBjNfYkCOfVTrtGtOgjRpD7aNowdR" +
		"hdLhiGuVOYCsOmnrUx4bhfz4TTkmK#t77dXuwlXu8WMu0a8yBKlml2p9ywaqpvSoF2lAyKI" +
		"gmBEa8a#EIaLaD#SUqP9xxIayzojpJp#Tk$gP06hotF7Pj5MupuVr3OiOepPFdBeyRy9dpB" +
		"aMdutehJZxbbAitfFi93l9JhAJx2GxoKwo$mzsx7tClB$5iyHggg4wQk0i1qluTkVX7RU0a" +
		"MvZU$Wwpx3S39rzkKMAlXcQVSdWNoE#DJDu6yv4Axv0J7tXlZpaUbd3v3LcZIpU$MhnbP9D" +
		"MoVsnyVRUNs#1ZloPUtK9YTRE4fqUrkZFKV3onUIXn5oAJdIXhJZYEABEofccXePUVSnYVQ" +
		"IeVzpbJ$2TgkJ7#TPz4IrpyrF8fwyZYCKzkFbNsAUdFsujRd0Ko9#tDhK9S7skFVERGKbDY" +
		"E9UCfVRMvjShRRLriRVek#g5OckeQYQ$def$1l9V7sDA0Viqwjc1Wfn$WbssFu8Z4yHUgpK" +
		"uHOFvdiGMER9GMTkLFzLn7YzQ49cgBPCKOmwxf5EFvH2fycDNcQDE1VmVuGFid2#qr3sNVZ" +
		"#KbKbygpe2Qz0FiVHlWNo6JIB9pF5#h6KIf9$cV14Ko64eS3GTOFzABSL50db2QyFCf6odW" +
		"MnX37qdQzQGjMOxA0kXNK3Gxh57yi3pJjE5byxMQoJdI7QF#1#1lhPmEUClh$Fl3K0lpV4P" +
		"i31cDukX6d4FiIvn47azU9E9hr6TSpb#NAnBKiroOU83Oa7cKy#WeEfBqTiQl4hGXuIz7sU" +
		"VJOU6kmtYR9fp7M2SJERCiVLFIdZMFZlO5ur5hFBeppA7aF4Kybla2i8$fXBCyYib$ULSGS" +
		"qR$CybuYnzrxX7YRw3S3lXB4HuXLYI#A$cEMcn2d4JiIbuYU$VNr8NAUVFSJ3ud#5vP7iTr" +
		"bpR9lEdM7PJvQihoSjiPYsqLTK6mPB7D#0ctCiZz8NVuySloDS1y$aR91oINd368zuQUoRb" +
		"ypRt0iGbnVHXEnTM2#4h4tCPru3x5Tz3Y6VfIw$GJ92JrEOLm$rsmeNNW7QUCS#xb6GbS9z" +
		"qwMbx8yH3Wo5WRxxj$ESfYxC3gUCOF2#J6udemdAK#p$Pm3W#lT$otvYvYVQ7BvlS7O6Zlt" +
		"0QwNG5ERBjsID$Bp$3na3WASoy1Zb5mBRsYiR$zciNriuRKI$5AmkyKssf9V8RXQC2#wNh2" +
		"yO4L1cQTWJy41WeC4Hmak5jmhUA0WPcXZTFj3zMFx56fWoQSAIko0O2ZBNY#Ua9SjsCEclr" +
		"nme4r$d#23DlqKmHas$Mp1UJRz5i7jDlq#I$vWjCsmvdqsMz2IBn5j2uwCxRTHsf8lMv0tr" +
		"m9Zrn2RZ6$#DsYasNqv2VajukWkj9LRM$gytwBlBTW$lk$0a3ZSVkvjmduJr3$gB$MdpXrL" +
		"lwZV83zrHFselbVSnTGdiFpKTv7SjphzXlAP#fJfMvGtAOifRr3urQk559vkQZw5kuEQGvb" +
		"DuMwXPb9cg7UrbrqwNQsMg7VKsphFyqfnpr7SgzKghPcgLgeLQhbQfjvJIoqjscd9xx3ajr" +
		"losopvhPRy5i7DEjqafOqw$L1AUJhT8AKF8dNVr#aKAV5iKHzHkAUg0sgoEgGcCJTHhL9Vg" +
		"CyZTRwEvBuI$58TLZz5j7#edzNlYFDJUtMwLgq9tmxGKx#Gita7wagyIAGr0hmfUIXUtff0" +
		"yUYRKWunHxzteT#yMSGiRGk913JFnB3u#UBsYFYqT6Bz3lezxk4xm1kHzlJLdhgsACdxAYW" +
		"Utj3yb60Xue#BNLYtIwIkNx$ASrdE96OIMnGYpMF4TnpY5Gc8XAJiGxT$0KTQViK=");

	private final Action[] actions;

	public BonesParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$script = script
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$script = lst$script script
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [2] program = lst$script.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final util.Node[] s = _list_s == null ? new util.Node[0] : (util.Node[]) _list_s.toArray(new util.Node[_list_s.size()]);
					 return new flowcontrol.Program(s);
				}
			},
			new Action() {	// [3] script = stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final util.Node s = (util.Node) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [4] script = funcdecl.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final util.Node f = (util.Node) _symbol_f.value;
					 return f;
				}
			},
			new Action() {	// [5] elseif = ELSEIF LPAR expr.e RPAR stmt.block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final util.Node e = (util.Node) _symbol_e.value;
					final Symbol _symbol_block = _symbols[offset + 5];
					final util.Node block = (util.Node) _symbol_block.value;
					 return new flowcontrol.ElseIf(e,block);
				}
			},
			new Action() {	// [6] lst$stmt = stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [7] lst$stmt = lst$stmt stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [8] opt$lst$stmt = 
			Action.RETURN,	// [9] opt$lst$stmt = lst$stmt
			new Action() {	// [10] stmt = LCUR opt$lst$stmt.block RCUR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_block = _symbols[offset + 2];
					final ArrayList _list_block = (ArrayList) _symbol_block.value;
					final util.Node[] block = _list_block == null ? new util.Node[0] : (util.Node[]) _list_block.toArray(new util.Node[_list_block.size()]);
					 return new flowcontrol.Block(block);
				}
			},
			new Action() {	// [11] lst$elseif = elseif
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [12] lst$elseif = lst$elseif elseif
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [13] opt$lst$elseif = 
			Action.RETURN,	// [14] opt$lst$elseif = lst$elseif
			Action.NONE,  	// [15] opt$else = 
			Action.RETURN,	// [16] opt$else = else
			new Action() {	// [17] stmt = IF LPAR expr.ife RPAR stmt.ifblock opt$lst$elseif.elseiflist opt$else.elseblock
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ife = _symbols[offset + 3];
					final util.Node ife = (util.Node) _symbol_ife.value;
					final Symbol _symbol_ifblock = _symbols[offset + 5];
					final util.Node ifblock = (util.Node) _symbol_ifblock.value;
					final Symbol _symbol_elseiflist = _symbols[offset + 6];
					final ArrayList _list_elseiflist = (ArrayList) _symbol_elseiflist.value;
					final util.Node[] elseiflist = _list_elseiflist == null ? new util.Node[0] : (util.Node[]) _list_elseiflist.toArray(new util.Node[_list_elseiflist.size()]);
					final Symbol _symbol_elseblock = _symbols[offset + 7];
					final util.Node elseblock = (util.Node) _symbol_elseblock.value;
					 return new flowcontrol.If(ife,ifblock,elseiflist,elseblock);
				}
			},
			new Action() {	// [18] stmt = FOR LPAR ID.id IN expr.e RPAR stmt.block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final util.Node e = (util.Node) _symbol_e.value;
					final Symbol _symbol_block = _symbols[offset + 7];
					final util.Node block = (util.Node) _symbol_block.value;
					 return new flowcontrol.For(id,e,block);
				}
			},
			new Action() {	// [19] stmt = WHILE LPAR expr.e RPAR stmt.block
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final util.Node e = (util.Node) _symbol_e.value;
					final Symbol _symbol_block = _symbols[offset + 5];
					final util.Node block = (util.Node) _symbol_block.value;
					 return new flowcontrol.While(e,block);
				}
			},
			new Action() {	// [20] stmt = PRINT printlist.lst SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 2];
					final ArrayList<Object> lst = (ArrayList<Object>) _symbol_lst.value;
					 return new flowcontrol.Print(lst);
				}
			},
			new Action() {	// [21] stmt = VAR ID.id ASN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new flowcontrol.VarDecl(id,e);
				}
			},
			new Action() {	// [22] stmt = CONSTVAR ID.id ASN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new flowcontrol.ConstVarDecl(id,e);
				}
			},
			new Action() {	// [23] stmt = ID.id ASN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new flowcontrol.VarAssign(id,e);
				}
			},
			new Action() {	// [24] printlist = STRING.str
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_str = _symbols[offset + 1];
					final String str = (String) _symbol_str.value;
					 ArrayList<Object> lst = new ArrayList<Object>(); lst.add(str); return new Symbol(lst);
				}
			},
			new Action() {	// [25] printlist = expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final util.Node e = (util.Node) _symbol_e.value;
					 ArrayList<Object> lst = new ArrayList<Object>(); lst.add(e); return new Symbol(lst);
				}
			},
			new Action() {	// [26] printlist = printlist.lst COMMA STRING.str
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 1];
					final ArrayList<Object> lst = (ArrayList<Object>) _symbol_lst.value;
					final Symbol _symbol_str = _symbols[offset + 3];
					final String str = (String) _symbol_str.value;
					 lst.add(str); return new Symbol(lst);
				}
			},
			new Action() {	// [27] printlist = printlist.lst COMMA expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 1];
					final ArrayList<Object> lst = (ArrayList<Object>) _symbol_lst.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final util.Node e = (util.Node) _symbol_e.value;
					 lst.add(e); return new Symbol(lst);
				}
			},
			new Action() {	// [28] else = ELSE stmt.elseblock
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_elseblock = _symbols[offset + 2];
					final util.Node elseblock = (util.Node) _symbol_elseblock.value;
					 return new flowcontrol.Else(elseblock);
				}
			},
			new Action() {	// [29] rollmodlist = rollmodlist.lst COMMA rollmod.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 1];
					final ArrayList<dice.Rollmod> lst = (ArrayList<dice.Rollmod>) _symbol_lst.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final dice.Rollmod r = (dice.Rollmod) _symbol_r.value;
					 lst.add(r); return new Symbol(lst);
				}
			},
			new Action() {	// [30] rollmodlist = rollmod.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_r = _symbols[offset + 1];
					final dice.Rollmod r = (dice.Rollmod) _symbol_r.value;
					 ArrayList<dice.Rollmod> lst = new ArrayList<dice.Rollmod>(); lst.add(r); return new Symbol(lst);
				}
			},
			new Action() {	// [31] rollmod = EXPLODE expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new dice.Rollmod_Explode(e);
				}
			},
			new Action() {	// [32] rollmod = DESPLODE expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new dice.Rollmod_Desplode(e);
				}
			},
			new Action() {	// [33] rollmod = ROLLAGAIN expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final util.Node e = (util.Node) _symbol_e.value;
					 return new dice.Rollmod_Rollagain(e);
				}
			},
			Action.NONE,  	// [34] opt$paramlist = 
			Action.RETURN,	// [35] opt$paramlist = paramlist
			new Action() {	// [36] funcdecl = FUNC ID.id LPAR opt$paramlist.lst RPAR LCUR opt$lst$stmt.block RETURN expr.ret SEMI RCUR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_lst = _symbols[offset + 4];
					final ArrayList<String> lst = (ArrayList<String>) _symbol_lst.value;
					final Symbol _symbol_block = _symbols[offset + 7];
					final ArrayList _list_block = (ArrayList) _symbol_block.value;
					final util.Node[] block = _list_block == null ? new util.Node[0] : (util.Node[]) _list_block.toArray(new util.Node[_list_block.size()]);
					final Symbol _symbol_ret = _symbols[offset + 9];
					final util.Node ret = (util.Node) _symbol_ret.value;
					 return new functions.FuncDecl(id,lst,block,ret);
				}
			},
			Action.NONE,  	// [37] opt$exprlist = 
			Action.RETURN,	// [38] opt$exprlist = exprlist
			new Action() {	// [39] callexpr = ID.id LPAR opt$exprlist.list RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_list = _symbols[offset + 3];
					final ArrayList<util.Node> list = (ArrayList<util.Node>) _symbol_list.value;
					 return new functions.CallFunc(id,list);
				}
			},
			new Action() {	// [40] callexpr = F_GT LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Gt(a,b);
				}
			},
			new Action() {	// [41] callexpr = F_GE LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Ge(a,b);
				}
			},
			new Action() {	// [42] callexpr = F_LT LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Lt(a,b);
				}
			},
			new Action() {	// [43] callexpr = F_LE LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Le(a,b);
				}
			},
			new Action() {	// [44] callexpr = F_EQ LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Eq(a,b);
				}
			},
			new Action() {	// [45] callexpr = F_NEQ LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Neq(a,b);
				}
			},
			new Action() {	// [46] callexpr = F_HIGHEST LPAR expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new functions.Highest(a,null);
				}
			},
			new Action() {	// [47] callexpr = F_HIGHEST LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Highest(a,b);
				}
			},
			new Action() {	// [48] callexpr = F_LOWEST LPAR expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new functions.Lowest(a,null);
				}
			},
			new Action() {	// [49] callexpr = F_LOWEST LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Lowest(a,b);
				}
			},
			new Action() {	// [50] callexpr = F_PICK LPAR expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new functions.Pick(a,null);
				}
			},
			new Action() {	// [51] callexpr = F_PICK LPAR expr.a COMMA expr.b RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new functions.Pick(a,b);
				}
			},
			Action.NONE,  	// [52] opt$STRING = 
			Action.RETURN,	// [53] opt$STRING = STRING
			new Action() {	// [54] callexpr = F_INPUT LPAR opt$STRING.str RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_str = _symbols[offset + 3];
					final String str = (String) _symbol_str.value;
					 return new functions.Input(str);
				}
			},
			new Action() {	// [55] callexpr = F_SIZEOF LPAR expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new functions.Sizeof(a);
				}
			},
			new Action() {	// [56] paramlist = paramlist.lst COMMA ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 1];
					final ArrayList<String> lst = (ArrayList<String>) _symbol_lst.value;
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					 lst.add(id); return new Symbol(lst);
				}
			},
			new Action() {	// [57] paramlist = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 ArrayList<String> lst = new ArrayList<String>(); lst.add(id); return new Symbol(lst);
				}
			},
			new Action() {	// [58] exprlist = exprlist.lst COMMA expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 1];
					final ArrayList<util.Node> lst = (ArrayList<util.Node>) _symbol_lst.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final util.Node e = (util.Node) _symbol_e.value;
					 lst.add(e); return new Symbol(lst);
				}
			},
			new Action() {	// [59] exprlist = expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final util.Node e = (util.Node) _symbol_e.value;
					 ArrayList<util.Node> lst = new ArrayList<util.Node>(); lst.add(e); return new Symbol(lst);
				}
			},
			new Action() {	// [60] dietype = D4
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d4);
				}
			},
			new Action() {	// [61] dietype = D6
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d6);
				}
			},
			new Action() {	// [62] dietype = D8
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d8);
				}
			},
			new Action() {	// [63] dietype = D10
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d10);
				}
			},
			new Action() {	// [64] dietype = D12
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d12);
				}
			},
			new Action() {	// [65] dietype = D20
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.Dietypes(dice.Dietypes.Die.d20);
				}
			},
			new Action() {	// [66] expr = ID.id
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new expr.Variable(id);
				}
			},
			new Action() {	// [67] expr = INTLIT.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new expr.IntLit(i);
				}
			},
			new Action() {	// [68] expr = dietype.die
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_die = _symbols[offset + 1];
					final util.Node die = (util.Node) _symbol_die.value;
					 return die;
				}
			},
			new Action() {	// [69] expr = callexpr.calle
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_calle = _symbols[offset + 1];
					final util.Node calle = (util.Node) _symbol_calle.value;
					 return calle;
				}
			},
			new Action() {	// [70] expr = expr.a UNION expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Union(a,b);
				}
			},
			new Action() {	// [71] expr = expr.a COMPLEMENT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Complement(a,b);
				}
			},
			new Action() {	// [72] expr = expr.a INTERSECT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Intersect(a,b);
				}
			},
			new Action() {	// [73] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Plus(a,b);
				}
			},
			new Action() {	// [74] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Minus(a,b);
				}
			},
			new Action() {	// [75] expr = expr.a MULT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Mult(a,b);
				}
			},
			new Action() {	// [76] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Div(a,b);
				}
			},
			new Action() {	// [77] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Mod(a,b);
				}
			},
			new Action() {	// [78] expr = LPAR expr.a RPAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final util.Node a = (util.Node) _symbol_a.value;
					 return a;
				}
			},
			new Action() {	// [79] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Gt(a,b);
				}
			},
			new Action() {	// [80] expr = expr.a EQGT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Ge(a,b);
				}
			},
			new Action() {	// [81] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Lt(a,b);
				}
			},
			new Action() {	// [82] expr = expr.a EQLT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Le(a,b);
				}
			},
			new Action() {	// [83] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Eq(a,b);
				}
			},
			new Action() {	// [84] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final util.Node a = (util.Node) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final util.Node b = (util.Node) _symbol_b.value;
					 return new expr.Neq(a,b);
				}
			},
			new Action() {	// [85] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new expr.Bang(a);
				}
			},
			new Action() {	// [86] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final util.Node a = (util.Node) _symbol_a.value;
					 return new expr.Negative(a);
				}
			},
			new Action() {	// [87] expr = LBRA expr.from TO expr.to RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_from = _symbols[offset + 2];
					final util.Node from = (util.Node) _symbol_from.value;
					final Symbol _symbol_to = _symbols[offset + 4];
					final util.Node to = (util.Node) _symbol_to.value;
					 return new dice.Range(from,to);
				}
			},
			new Action() {	// [88] expr = LBRA expr.numdice COLO expr.dietype RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_numdice = _symbols[offset + 2];
					final util.Node numdice = (util.Node) _symbol_numdice.value;
					final Symbol _symbol_dietype = _symbols[offset + 4];
					final util.Node dietype = (util.Node) _symbol_dietype.value;
					 return new dice.Roll(numdice,dietype, null);
				}
			},
			new Action() {	// [89] expr = LBRA expr.numdice COLO expr.dietype COLO rollmodlist.lst RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_numdice = _symbols[offset + 2];
					final util.Node numdice = (util.Node) _symbol_numdice.value;
					final Symbol _symbol_dietype = _symbols[offset + 4];
					final util.Node dietype = (util.Node) _symbol_dietype.value;
					final Symbol _symbol_lst = _symbols[offset + 6];
					final ArrayList<dice.Rollmod> lst = (ArrayList<dice.Rollmod>) _symbol_lst.value;
					 return new dice.Roll(numdice,dietype,lst);
				}
			},
			new Action() {	// [90] expr = LBRA RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new dice.EmptyPool();
				}
			},
			new Action() {	// [91] expr = LBRA exprlist.lst RBRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_lst = _symbols[offset + 2];
					final ArrayList<util.Node> lst = (ArrayList<util.Node>) _symbol_lst.value;
					 return new dice.ExprPool(lst);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
